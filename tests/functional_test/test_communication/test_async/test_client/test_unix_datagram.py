from __future__ import annotations

import asyncio
import contextlib
import pathlib
import sys
from collections.abc import AsyncIterator, Callable
from socket import socket as Socket
from typing import TYPE_CHECKING, Any, NoReturn

import pytest
import pytest_asyncio
import sniffio

from .....fixtures.trio import trio_fixture
from .....tools import PlatformMarkers, is_uvloop_event_loop
from .._utils import delay
from ..socket import AsyncDatagramSocket

if sys.platform != "win32":
    from easynetwork.clients.async_unix_datagram import AsyncUnixDatagramClient
    from easynetwork.exceptions import ClientClosedError, DatagramProtocolParseError
    from easynetwork.lowlevel.socket import SocketProxy
    from easynetwork.protocol import DatagramProtocol

    if TYPE_CHECKING:
        import trio

        from .....pytest_plugins.unix_sockets import UnixSocketPathFactory

    @pytest.fixture
    def bound_unix_datagram_socket_factory(
        request: pytest.FixtureRequest,
        unix_datagram_socket_factory: Callable[[], Socket],
        unix_socket_path_factory: UnixSocketPathFactory,
    ) -> Callable[[], Socket]:
        use_unix_address_type: str | None = getattr(request, "param", None)

        def bound_unix_datagram_socket_factory() -> Socket:
            sock = unix_datagram_socket_factory()
            match use_unix_address_type:
                case "PATHNAME" | None:
                    sock.bind(unix_socket_path_factory())
                case "ABSTRACT":
                    sock.bind("")
                case _:
                    sock.close()
                    pytest.fail(f"Invalid use_unix_address_type parameter: {request.param}")
            return sock

        return bound_unix_datagram_socket_factory

    @pytest.mark.flaky(retries=3, delay=0.1)
    class _BaseTestAsyncUnixDatagramClient:

        async def test____aclose____idempotent(self, client: AsyncUnixDatagramClient[str, str]) -> None:
            assert not client.is_closing()
            await client.aclose()
            assert client.is_closing()
            await client.aclose()
            assert client.is_closing()

        async def test____send_packet____default(
            self,
            client: AsyncUnixDatagramClient[str, str],
            server: AsyncDatagramSocket,
        ) -> None:
            await client.send_packet("ABCDEF")
            with client.backend().timeout(3):
                assert await server.recvfrom() == (b"ABCDEF", client.get_local_name().as_raw())

        async def test____send_packet____closed_client(
            self,
            client: AsyncUnixDatagramClient[str, str],
        ) -> None:
            await client.aclose()
            with pytest.raises(ClientClosedError):
                await client.send_packet("ABCDEF")

        @pytest.mark.parametrize("datagram_protocol", [pytest.param("bad_serialize", id="serializer_crash")], indirect=True)
        async def test____send_packet____protocol_crashed(
            self,
            client: AsyncUnixDatagramClient[str, str],
        ) -> None:
            with pytest.raises(RuntimeError, match=r"^protocol\.make_datagram\(\) crashed$"):
                await client.send_packet("ABCDEF")

        async def test____recv_packet____default(
            self,
            client: AsyncUnixDatagramClient[str, str],
            server: AsyncDatagramSocket,
        ) -> None:
            await server.sendto(b"ABCDEF", client.get_local_name().as_raw())
            with client.backend().timeout(3):
                assert await client.recv_packet() == "ABCDEF"

        async def test____recv_packet____closed_client(
            self,
            client: AsyncUnixDatagramClient[str, str],
        ) -> None:
            await client.aclose()
            with pytest.raises(ClientClosedError):
                await client.recv_packet()

        async def test____recv_packet____client_close_while_waiting(
            self,
            client: AsyncUnixDatagramClient[str, str],
        ) -> None:
            async with client.backend().create_task_group() as tg:
                await tg.start(delay, 0.5, client.aclose)
                with client.backend().timeout(5), pytest.raises(ClientClosedError):
                    assert await client.recv_packet()

        async def test____recv_packet____invalid_data(
            self, client: AsyncUnixDatagramClient[str, str], server: AsyncDatagramSocket
        ) -> None:
            await server.sendto("\u00e9".encode("latin-1"), client.get_local_name().as_raw())
            with pytest.raises(DatagramProtocolParseError):
                with client.backend().timeout(3):
                    await client.recv_packet()

        @pytest.mark.parametrize("datagram_protocol", [pytest.param("invalid", id="serializer_crash")], indirect=True)
        async def test____recv_packet____protocol_crashed(
            self,
            client: AsyncUnixDatagramClient[str, str],
            server: AsyncDatagramSocket,
        ) -> None:
            await server.sendto(b"ABCDEF", client.get_local_name().as_raw())
            try:
                await client.recv_packet()
            except NotImplementedError:
                raise
            except Exception:
                with pytest.raises(RuntimeError, match=r"^protocol\.build_packet_from_datagram\(\) crashed$"):
                    raise

        async def test____iter_received_packets____yields_available_packets_until_close(
            self,
            client: AsyncUnixDatagramClient[str, str],
            server: AsyncDatagramSocket,
        ) -> None:
            for p in [b"A", b"B", b"C", b"D", b"E", b"F"]:
                await server.sendto(p, client.get_local_name().as_raw())

            async with client.backend().create_task_group() as tg:
                await tg.start(delay, 0.5, client.aclose)
                # NOTE: Comparison using set because equality check does not verify order
                assert {p async for p in client.iter_received_packets(timeout=None)} == {"A", "B", "C", "D", "E", "F"}

        async def test____iter_received_packets____yields_available_packets_until_timeout(
            self,
            client: AsyncUnixDatagramClient[str, str],
            server: AsyncDatagramSocket,
        ) -> None:
            for p in [b"A", b"B", b"C", b"D", b"E", b"F"]:
                await server.sendto(p, client.get_local_name().as_raw())

            # NOTE: Comparison using set because equality check does not verify order
            assert {p async for p in client.iter_received_packets(timeout=1)} == {"A", "B", "C", "D", "E", "F"}

        async def test____get_local_name____consistency(self, client: AsyncUnixDatagramClient[str, str]) -> None:
            from easynetwork.lowlevel.socket import UnixSocketAddress

            address = client.get_local_name()
            assert isinstance(address, UnixSocketAddress)
            assert address.as_raw() == client.socket.getsockname()

        async def test____get_peer_name____consistency(self, client: AsyncUnixDatagramClient[str, str]) -> None:
            from easynetwork.lowlevel.socket import UnixSocketAddress

            address = client.get_peer_name()
            assert isinstance(address, UnixSocketAddress)
            assert address.as_raw() == client.socket.getpeername()

    @pytest.mark.asyncio
    class TestAsyncUnixDatagramClientWithAsyncIO(_BaseTestAsyncUnixDatagramClient):
        @pytest_asyncio.fixture
        @staticmethod
        async def server(bound_unix_datagram_socket_factory: Callable[[], Socket]) -> AsyncIterator[AsyncDatagramSocket]:
            async with await AsyncDatagramSocket.from_stdlib_socket(bound_unix_datagram_socket_factory()) as server:
                yield server

        @pytest_asyncio.fixture
        @staticmethod
        async def client(
            server: AsyncDatagramSocket,
            bound_unix_datagram_socket_factory: Callable[[], Socket],
            datagram_protocol: DatagramProtocol[str, str],
        ) -> AsyncIterator[AsyncUnixDatagramClient[str, str]]:
            remote_address: str | bytes = server.getsockname()
            socket = bound_unix_datagram_socket_factory()
            socket.connect(remote_address)

            async with AsyncUnixDatagramClient(socket, datagram_protocol, "asyncio") as client:
                assert client.is_connected()
                yield client

    @pytest.mark.feature_trio(async_test_auto_mark=True)
    class TestAsyncUnixDatagramClientWithTrio(_BaseTestAsyncUnixDatagramClient):
        @trio_fixture
        @staticmethod
        async def server(bound_unix_datagram_socket_factory: Callable[[], Socket]) -> AsyncIterator[AsyncDatagramSocket]:
            async with await AsyncDatagramSocket.from_stdlib_socket(bound_unix_datagram_socket_factory()) as server:
                yield server

        @trio_fixture
        @staticmethod
        async def client(
            server: AsyncDatagramSocket,
            bound_unix_datagram_socket_factory: Callable[[], Socket],
            datagram_protocol: DatagramProtocol[str, str],
        ) -> AsyncIterator[AsyncUnixDatagramClient[str, str]]:
            remote_address: str | bytes = server.getsockname()
            socket = bound_unix_datagram_socket_factory()
            socket.connect(remote_address)

            async with AsyncUnixDatagramClient(socket, datagram_protocol, "trio") as client:
                assert client.is_connected()
                yield client

    @pytest.mark.parametrize(
        "bound_unix_datagram_socket_factory",
        [
            pytest.param("PATHNAME"),
            pytest.param("ABSTRACT", marks=PlatformMarkers.supports_abstract_sockets),
        ],
        indirect=True,
    )
    class _BaseTestAsyncUnixDatagramClientConnection:

        @pytest.fixture
        @staticmethod
        def local_path(unix_socket_path_factory: UnixSocketPathFactory) -> str:
            return unix_socket_path_factory()

        @PlatformMarkers.supports_abstract_sockets
        async def test____dunder_init____automatic_local_name(
            self,
            remote_address: str | bytes,
            datagram_protocol: DatagramProtocol[str, str],
        ) -> None:
            if sniffio.current_async_library() == "asyncio" and is_uvloop_event_loop(asyncio.get_running_loop()):
                # Addresses received through uvloop transports contains extra NULL bytes because the creation of
                # the bytes object from the sockaddr_un structure does not take into account the real addrlen.
                # https://github.com/MagicStack/uvloop/blob/v0.21.0/uvloop/includes/compat.h#L34-L55
                pytest.xfail("uvloop translation of abstract unix sockets to python object is wrong.")

            async with AsyncUnixDatagramClient(remote_address, datagram_protocol) as client:
                assert client.is_connected()
                assert not client.get_local_name().is_unnamed()

                with client.backend().timeout(3):
                    await client.send_packet("Test")
                    assert await client.recv_packet() == "Test"

        @PlatformMarkers.abstract_sockets_unsupported
        async def test____dunder_init____automatic_local_name____unsupported_by_current_platform(
            self,
            remote_address: str | bytes,
            datagram_protocol: DatagramProtocol[str, str],
        ) -> None:
            with pytest.raises(
                ValueError,
                match=r"^local_path parameter is required on this platform and cannot be an empty string\.",
            ):
                _ = AsyncUnixDatagramClient(remote_address, datagram_protocol)

        async def test____dunder_init____with_local_name(
            self,
            local_path: str,
            remote_address: str | bytes,
            datagram_protocol: DatagramProtocol[str, str],
        ) -> None:
            async with AsyncUnixDatagramClient(remote_address, datagram_protocol, local_path=local_path) as client:
                assert client.is_connected()
                assert client.get_local_name().as_pathname() == pathlib.Path(local_path)

                with client.backend().timeout(5):
                    await client.send_packet("Test")
                    assert await client.recv_packet() == "Test"

        async def test____dunder_init____peer_name____not_set(
            self,
            bound_unix_datagram_socket_factory: Callable[[], Socket],
            datagram_protocol: DatagramProtocol[str, str],
        ) -> None:
            from easynetwork.clients.async_unix_datagram import AsyncUnixDatagramClient

            with pytest.raises(OSError):
                _ = AsyncUnixDatagramClient(bound_unix_datagram_socket_factory(), datagram_protocol)

        async def test____dunder_init____local_name____not_set(
            self,
            remote_address: str | bytes,
            unix_datagram_socket_factory: Callable[[], Socket],
            datagram_protocol: DatagramProtocol[str, str],
        ) -> None:
            sock = unix_datagram_socket_factory()
            sock.connect(remote_address)
            assert not sock.getsockname()
            with pytest.raises(ValueError, match=r"^AsyncUnixDatagramClient requires the socket to be named.$"):
                _ = AsyncUnixDatagramClient(sock, datagram_protocol)

        async def test____wait_connected____idempotent(
            self,
            local_path: str,
            remote_address: str | bytes,
            datagram_protocol: DatagramProtocol[str, str],
        ) -> None:
            async with contextlib.aclosing(
                AsyncUnixDatagramClient(
                    remote_address,
                    datagram_protocol,
                    local_path=local_path,
                )
            ) as client:
                await client.wait_connected()
                assert client.is_connected()
                await client.wait_connected()
                assert client.is_connected()

        async def test____wait_connected____simultaneous(
            self,
            local_path: str,
            remote_address: str | bytes,
            datagram_protocol: DatagramProtocol[str, str],
        ) -> None:
            async with contextlib.aclosing(
                AsyncUnixDatagramClient(
                    remote_address,
                    datagram_protocol,
                    local_path=local_path,
                )
            ) as client:
                await client.backend().gather(*[client.wait_connected() for _ in range(5)])
                assert client.is_connected()

        async def test____wait_connected____is_closing____connection_not_performed_yet(
            self,
            local_path: str,
            remote_address: str | bytes,
            datagram_protocol: DatagramProtocol[str, str],
        ) -> None:
            async with contextlib.aclosing(
                AsyncUnixDatagramClient(
                    remote_address,
                    datagram_protocol,
                    local_path=local_path,
                )
            ) as client:
                assert not client.is_connected()
                assert not client.is_closing()
                await client.wait_connected()
                assert client.is_connected()
                assert not client.is_closing()

        async def test____wait_connected____close_before_trying_to_connect(
            self,
            local_path: str,
            remote_address: str | bytes,
            datagram_protocol: DatagramProtocol[str, str],
        ) -> None:
            client = AsyncUnixDatagramClient(
                remote_address,
                datagram_protocol,
                local_path=local_path,
            )
            await client.aclose()
            with pytest.raises(ClientClosedError):
                await client.wait_connected()

        async def test____socket_property____connection_not_performed_yet(
            self,
            local_path: str,
            remote_address: str | bytes,
            datagram_protocol: DatagramProtocol[str, str],
        ) -> None:
            async with contextlib.aclosing(
                AsyncUnixDatagramClient(
                    remote_address,
                    datagram_protocol,
                    local_path=local_path,
                )
            ) as client:
                with pytest.raises(AttributeError):
                    _ = client.socket

                await client.wait_connected()

                assert isinstance(client.socket, SocketProxy)
                assert client.socket is client.socket

        async def test____get_local_name____connection_not_performed_yet(
            self,
            local_path: str,
            remote_address: str | bytes,
            datagram_protocol: DatagramProtocol[str, str],
        ) -> None:
            async with contextlib.aclosing(
                AsyncUnixDatagramClient(
                    remote_address,
                    datagram_protocol,
                    local_path=local_path,
                )
            ) as client:
                with pytest.raises(OSError):
                    _ = client.get_local_name()

                await client.wait_connected()

                assert client.get_local_name().as_raw() == local_path

        async def test____get_peer_name____connection_not_performed_yet(
            self,
            local_path: str,
            remote_address: str | bytes,
            datagram_protocol: DatagramProtocol[str, str],
        ) -> None:
            async with contextlib.aclosing(
                AsyncUnixDatagramClient(
                    remote_address,
                    datagram_protocol,
                    local_path=local_path,
                )
            ) as client:
                with pytest.raises(OSError):
                    _ = client.get_peer_name()

                await client.wait_connected()

                assert client.get_peer_name().as_raw() == remote_address

        async def test____send_packet____recv_packet____implicit_connection(
            self,
            local_path: str,
            remote_address: str | bytes,
            datagram_protocol: DatagramProtocol[str, str],
        ) -> None:
            async with contextlib.aclosing(
                AsyncUnixDatagramClient(
                    remote_address,
                    datagram_protocol,
                    local_path=local_path,
                )
            ) as client:
                assert not client.is_connected()

                with client.backend().timeout(3):
                    await client.send_packet("Connected")
                    assert await client.recv_packet() == "Connected"

                assert client.is_connected()

    @pytest.mark.asyncio
    class TestAsyncUnixDatagramClientConnectionWithAsyncIO(_BaseTestAsyncUnixDatagramClientConnection):
        class EchoProtocol(asyncio.DatagramProtocol):
            transport: asyncio.DatagramTransport | None = None

            def __init__(self) -> None:
                super().__init__()
                self.connection_lost_event = asyncio.Event()

            def connection_made(self, transport: asyncio.DatagramTransport) -> None:  # type: ignore[override]
                self.transport = transport

            def connection_lost(self, exc: Exception | None) -> None:
                self.transport = None
                self.connection_lost_event.set()

            def datagram_received(self, data: bytes, addr: Any) -> None:
                if self.transport is not None:
                    self.transport.sendto(data, addr)

        @pytest_asyncio.fixture
        @classmethod
        async def server(
            cls,
            bound_unix_datagram_socket_factory: Callable[[], Socket],
        ) -> AsyncIterator[asyncio.DatagramTransport]:
            event_loop = asyncio.get_running_loop()

            # Caveat: uvloop does not support having a UNIX socket address for "local_addr" parameter.
            # The socket must be created manually.
            sock = bound_unix_datagram_socket_factory()
            try:
                from easynetwork.lowlevel.socket import UnixSocketAddress

                local_addr = UnixSocketAddress.from_raw(sock.getsockname())
                if sys.platform == "linux" and local_addr.as_abstract_name() and is_uvloop_event_loop(asyncio.get_running_loop()):
                    # Addresses received through uvloop transports contains extra NULL bytes because the creation of
                    # the bytes object from the sockaddr_un structure does not take into account the real addrlen.
                    # https://github.com/MagicStack/uvloop/blob/v0.21.0/uvloop/includes/compat.h#L34-L55
                    pytest.xfail("uvloop translation of abstract unix sockets to python object is wrong.")
                sock.setblocking(False)
            except BaseException:
                sock.close()
                raise
            transport, protocol = await event_loop.create_datagram_endpoint(cls.EchoProtocol, sock=sock)
            del sock
            try:
                with contextlib.closing(transport):
                    yield transport
            finally:
                await protocol.connection_lost_event.wait()

        @pytest.fixture
        @staticmethod
        def remote_address(server: asyncio.DatagramTransport) -> str | bytes:
            return server.get_extra_info("sockname")

    @pytest.mark.feature_trio(async_test_auto_mark=True)
    class TestAsyncUnixDatagramClientConnectionWithTrio(_BaseTestAsyncUnixDatagramClientConnection):
        @trio_fixture
        @classmethod
        async def server(
            cls,
            bound_unix_datagram_socket_factory: Callable[[], Socket],
            nursery: trio.Nursery,
        ) -> AsyncIterator[trio.socket.SocketType]:
            import trio

            async def echo_server(*, task_status: trio.TaskStatus[trio.socket.SocketType] = trio.TASK_STATUS_IGNORED) -> NoReturn:
                with trio.socket.from_stdlib_socket(bound_unix_datagram_socket_factory()) as server:
                    task_status.started(server)
                    while True:
                        data, addr = await server.recvfrom(65536)
                        await server.sendto(data, addr)
                        del data, addr

            yield await nursery.start(echo_server)

        @pytest.fixture
        @staticmethod
        def remote_address(server: trio.socket.SocketType) -> str | bytes:
            return server.getsockname()

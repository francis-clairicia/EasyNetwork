# -*- coding: Utf-8 -*-

from __future__ import annotations

from abc import abstractmethod
from functools import cache
from typing import Any, final

from easynetwork.serializers.exceptions import DeserializeError
from easynetwork.serializers.wrapper.base64 import Base64EncodedSerializer

import pytest

from .base import BaseTestIncrementalSerializer, NoSerialization


class BaseTestBase64EncodedSerializer(BaseTestIncrementalSerializer):
    @classmethod
    @abstractmethod
    def get_signing_key(cls) -> bytes | None:
        raise NotImplementedError

    @pytest.fixture(scope="class")
    @classmethod
    def serializer(cls) -> Base64EncodedSerializer[bytes, bytes]:
        return Base64EncodedSerializer(NoSerialization(), signing_key=cls.get_signing_key())

    @classmethod
    @cache
    def get_oneshot_serialize_sample(cls) -> list[tuple[Any, bytes, str]]:
        import base64
        import hmac
        import os

        key: bytes | None = cls.get_signing_key()
        if key is not None:
            key = base64.urlsafe_b64decode(key)

        return [
            (p, base64.urlsafe_b64encode(p + (hmac.digest(key, p, "sha256") if key is not None else b"")), id)
            for p, id in [
                (b"", "empty bytes"),
                (b"a", "one ascii byte"),
                (b"\xcc", "one unicode byte"),
                (os.urandom(255), "255 urandom generated bytes"),
            ]
        ]

    @classmethod
    @cache
    def get_incremental_serialize_sample(cls) -> list[tuple[Any, bytes, str]]:
        return [(p, s + b"\r\n", id) for p, s, id in cls.get_oneshot_serialize_sample()]

    @classmethod
    @cache
    def get_invalid_complete_data(cls) -> list[tuple[bytes, str]]:
        return [
            (s[:-1], f"{id} (minus one byte)")  # Remove one byte at last will break the padding
            for _, s, id in cls.get_oneshot_serialize_sample()
            if s
        ]

    @classmethod
    @cache
    def get_invalid_partial_data(cls) -> list[tuple[bytes, bytes, str]]:
        return [(s + b"\r\nremaining", b"remaining", id) for s, id in cls.get_invalid_complete_data()]


@final
class TestBase64EncodedSerializerNoKey(BaseTestBase64EncodedSerializer):
    @classmethod
    def get_signing_key(cls) -> None:
        return None


@final
class TestBase64EncodedSerializerWithKey(BaseTestBase64EncodedSerializer):
    KEY = Base64EncodedSerializer.generate_key()

    @classmethod
    def get_signing_key(cls) -> bytes:
        return cls.KEY

    def test____generate_key____create_url_safe_base64_encoded_bytes(self) -> None:
        # Arrange
        from base64 import urlsafe_b64decode

        # Act
        key = Base64EncodedSerializer.generate_key()

        # Assert
        assert isinstance(key, bytes)
        assert len(urlsafe_b64decode(key)) == 32

    def test____dunder_init____invalid_key____not_base64_encoded(self) -> None:
        # Arrange
        import base64
        import binascii
        import os

        key: bytes = base64.urlsafe_b64encode(os.urandom(32))[5:12]  # Removed a lot of data :)

        # Act
        with pytest.raises(ValueError, match=r"^signing key must be 32 url-safe base64-encoded bytes\.$") as exc_info:
            _ = Base64EncodedSerializer(NoSerialization(), signing_key=key)
        exception = exc_info.value

        # Assert
        assert isinstance(exception.__cause__, binascii.Error)

    def test____dunder_init____invalid_key____invalid_base64_encoded_byte_length(self) -> None:
        # Arrange
        import base64
        import binascii
        import os

        key: bytes = base64.urlsafe_b64encode(os.urandom(4))

        # Act
        with pytest.raises(ValueError, match=r"^signing key must be 32 url-safe base64-encoded bytes\.$") as exc_info:
            _ = Base64EncodedSerializer(NoSerialization(), signing_key=key)
        exception = exc_info.value

        # Assert
        assert not isinstance(exception.__cause__, binascii.Error)

    def test____deserialize____invalid_signature(
        self,
        serializer: Base64EncodedSerializer[bytes, bytes],
        data: bytes,
        serialized_data: bytes,
    ) -> None:
        # Arrange
        import base64
        import hmac

        while (another_key := Base64EncodedSerializer.generate_key()) == self.get_signing_key():
            continue
        data_with_another_signature = base64.urlsafe_b64encode(data + hmac.digest(another_key, data, "sha256"))
        assert data_with_another_signature != serialized_data

        # Act
        with pytest.raises(DeserializeError) as exc_info:
            serializer.deserialize(data_with_another_signature)
        exception = exc_info.value

        # Assert
        assert exception.__cause__ is None


def pytest_generate_tests(metafunc: pytest.Metafunc) -> None:
    if not issubclass(metafunc.cls, TestBase64EncodedSerializerWithKey):
        return
    if not metafunc.definition.name.endswith("invalid_signature"):
        return
    metafunc.parametrize(
        ["data", "serialized_data"],
        [pytest.param(p, s, id=id) for p, s, id in metafunc.cls.get_oneshot_serialize_sample()],
    )
